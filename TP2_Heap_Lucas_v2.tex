% % Apunte de modulos basicos
%
\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage{algorithmicx, algpseudocode, algorithm}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}


\hypersetup{%
 % Para que el PDF se abra a página completa.
 pdfstartview= {FitH \hypercalcbp{\paperheight-\topmargin-1in-\headheight}},
 pdfauthor={Cátedra de Algoritmos y Estructuras de Datos II - DC - UBA},
 pdfkeywords={Módulos básicos},
 pdftitle={Módulos básicos de diseño},
 pdfsubject={Módulos básicos de diseño}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PARAMETROS A SER MODIFICADOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%cuatrimestre de acuerdo a la opcion
\newcommand{\Cuatrimestre}{$2^\mathrm{do}$ cuatrimestre de 2016 (compilado?)}
%\newcommand{\Cuatrimestre}{$1^\mathrm{er}$ cuatrimestre de 2012 (compilado 08/05/2012)}
%\renewcommand{\Cuatrimestre}{$2^\mathrm{do}$ cuatrimestre de 2010 (compilado 13/05/2011)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OTRAS OPCIONES QUE NO HAY QUE MODIFICAR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%opening
\title{Apunte de Módulos Básicos (v.\ 0.3$\alpha$)}
\author{Algoritmos y Estructuras de Datos II, DC, UBA.}
\date{\Cuatrimestre}

% Acomodo fancyhdr.
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Algoritmos y Estructuras de Datos II}
\rhead{\Cuatrimestre}
\cfoot{\thepage /\pageref{LastPage}}
\renewcommand{\footrulewidth}{0.4pt}
\setlength{\headheight}{13pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% COMANDOS QUE ALGUN DIA PUEDAN FORMAR UN PAQUETE.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representación}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Titulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

%pagina de titulo
\thispagestyle{empty}

\section{Renombres de TADs}

\tadNombre{TAD JugadorHeap} es \tadNombre{Tupla(Nat,Nat)}

\section{Módulo Heap Modificable}

Este módulo implementa una cola de prioridad. El TAD Cola de prioridad es paramétrico, es posible utilizarlo con cualquier tipo $\alpha$ que tenga una relación de orden total estricto. Esta implementación se limita al tipo jugadorHeap, que es tupla <Nat, Nat>.

\begin{Interfaz}

  \textbf{se explica con}: \tadNombre{Cola de prioridad}, \tadNombre{jugadorHeap}.

  \textbf{géneros}: \TipoVariable{heapMod}.
  
  \Titulo{Operaciones básicas de Heap Modificable}
  
  \InterfazFuncion{Vacía?}{\In{c}{heapMod}}{bool}
  {res $\igobs$ vacía?(c)}
  [$\Theta(1)$]
  [Devuelve true si la cola de prioridad está vacia.]

  \InterfazFuncion{Próximo}{\In{c}{heapMod}}{JugadorHeap}
  [$\lnot$vacía?(c)]
  {alias($res$, próximo())}
  [$\Theta(1)$]
  [Retorna por referencia el próximo valor en la cola.]
  [La referencia es constante, el elemento a no puede modificarse]
  
  \InterfazFuncion{Desncolar}{\Inout{c}{heapMod}}{}
  [$\lnot$vacía?(c) $\land$ $c \igobs c_0$]
  {c $\igobs$ desencolar($c_0$)}
  [$\Theta(log(\#heapSecu(c)))$]
  [Desencola el próximo elemento.]
  
  \InterfazFuncion{Vacía}{}{heapMod$(\alpha)$}
  {$res$ $\igobs$ vacía()}
  [$\Theta(1)$]
  [Retorna por referencia una cola vacía.]

  \InterfazFuncion{Encolar}{\In{a}{JugadorHeap}, \Inout{c}{heapMod}}{itHeapMod}
  [$c \igobs c_0$]
  {c $\igobs$ encolar($c_0$) $\land$ res $\igobs$ AgregarComoSiguiente(CrearIt($c$), $a$)}
  [$\Theta(log(\#heapSecu(c)))$]
  [Encola el elemento JugadorHeap. Devuelve un iterador de forma tal que al pedir \NombreFuncion{Siguiente} se obtenga el elemento agregado.]
  
  \InterfazFuncion{Encolar}{\In{a}{JugadorHeap}, \In{b}{JugadorHeap}}{bool}
  {res $\igobs$ esMayor?($a$, $b$)}
  [$\Theta(1)$]
  [Devuelve $true$ si $a$ tiene mayor prioridad que $b$.]
  
  

  \Titulo{Operaciones del iterador}
  
  
  El iterador que presentamos permite modificar la cola de prioridad, pudiendo eliminar elementos que se encuentren en cualquier posición de la cola. No se incluyeron las funciones para avanzar y retroceder en la cola ya que no son necesarias para el proposito de esta cola de prioridad.

  \InterfazFuncion{CrearIt}{\In{c}{heapMod}}{itHeapMod}
  {$res$ $\igobs$ crearItBi(\secuencia{}, $c$) $\land$ alias(SecuSuby($it$) $=$ $c$)}
  [$\Theta(1)$]
  [crea un iterador bidireccional de la cola de prioridad, de forma tal que al pedir \NombreFuncion{Siguiente} se obtenga el primer elemento de $c$.]
  [el iterador se invalida si y sólo si se elimina el elemento siguiente del iterador sin utilizar la función \NombreFuncion{EliminarSiguiente}.]
  
  \InterfazFuncion{HaySiguiente}{\In{it}{itHeapMod}}{bool}
  {$res$ $\igobs$ haySiguiente?($it$)}
  [$\Theta(1)$]
  [devuelve \texttt{true} si y sólo si en el iterador todavía quedan elementos para avanzar.]
  
  \InterfazFuncion{Siguiente}{\In{it}{itHeapMod}}{JugadorHeap}
  [HaySiguiente?($it$)]
  {alias($res$ $\igobs$ Siguiente($it$))}
  [$\Theta(1)$]
  [devuelve el elemento siguiente a la posición del iterador.]
  [$res$ es modificable si y sólo si $it$ es modificable.]
  
  \InterfazFuncion{EliminarSiguiente}{\Inout{it}{itHeapMod}}{}
  [$it = it_0$ $\land$ HaySiguiente?($it$)]
  {$it$ $\igobs$ EliminarSiguiente($it_0$)}
  [$\Theta(log(\#heapSecu(c)))$]
  [elimina de la lista iterada el valor que se encuentra en la posición siguiente del iterador.]
  
  
  \InterfazFuncion{AgregarComoSiguiente}{\Inout{it}{itHeapMod}, \In{a}{JugadorHeap}}{}
  [$it = it_0$]
  {$it$ $\igobs$ AgregarComoSiguiente($it_0$, $a$)}
  [$\Theta(log(\#heapSecu(c)))$]
  [agrega el elemento $a$ a la cola de prioridad, dejando al iterador posicionado de forma tal que al llamar a \NombreFuncion{Siguiente} se obtenga $a$.]
  [el elemento $a$ se agrega por copia.]

  

  \Titulo{Especificación de las operaciones auxiliares utilizadas en la interfaz}
  
  \begin{tad}{Cola de Prioridad extendida}
    \parskip=0pt
    \tadExtiende{\tadNombre{Cola de Prioridad}}
    
    \tadTitulo{otras operaciones}
    
    \tadAlinearFunciones{esMayor?(a, b)}{jugadorHeap, jugadorHeap}
		\tadOperacion{esMayor?}{jugadorHeap, jugadorHeap}{bool}{}
		
    \tadTitulo{otras operaciones (no exportadas)}
    \tadOperacion{heapSecu}{heapMod}{secu(jugadorHeap)}{}
    
    \tadAxiomas
    \tadAlinearAxiomas{esMayor?(a, b)}
    \tadAxioma{esMayor?(a, b)}{\IF $\Pi_{1}(a) = \Pi_{1}(b)$ THEN $\Pi_{2}(a) < \Pi_{2}(b)$ ELSE $\Pi_{1}(a) < \Pi_{1}(b)$ FI}
    \tadAxioma{heapSecu(c)}{\IF vacía?(c) THEN $<>$ ELSE próximo(c) $\bullet$ heapSecu(desencolar(c)) FI}
    
  \end{tad}
  
   
\end{Interfaz}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Representacion}

  \Titulo{Representación de la Cola de Prioridad}
  
  En este módulo vamos a utilizar un árbol binario para representar la cola, donde cada nodo contiene un elemento. La prioridad de los hijos es siempre menor a la del padre, por lo tanto la raíz del árbol tiene el elemento de mayor prioridad. La altura del árbol es igual al logaritmo de la cantidad de elementos. Cada nivel del árbol se va llenando de izquierda a derecha. Cada nodo guarda el diferencia de profundidad entre la rama izquierda y la derecha, en una variable llamada $balance$. Debido a como se van colocando los nodos, la rama derecha nunca puede ser más larga que la izquierda, por lo tando la diferencia será 0, si la dos ramas son igual de largas, o 1, si la longitud de rama izquierda es mayor a la de la derecha (solo puede ser mayor en 1).
  
  \begin{Estructura}{heapMod}[heapmod]
    \begin{Tupla}[heapmod]
      \tupItem{tope}{puntero(nodo)}%
    \end{Tupla}  
  
    \begin{Tupla}[nodo]
      \tupItem{elemento}{jugadorHeap}%
      \tupItem{ramaMasCorta}{nat}%
      \tupItem{ramaMasLarga}{nat}%
      \tupItem{hijoIzq}{puntero(nodo)}%
      \tupItem{hijoDer}{puntero(nodo)}%
      \tupItem{padre}{puntero(nodo)}%
    \end{Tupla}
  \end{Estructura}

	%\RepFc[vector(puntero(nodo))][c]{true}
  \Rep[heapmod][c]{(c.tope.hijoIzq $\neq$ NULL $\impluego$ esMayor(c.elemento, (*c.hijoIzq).elemento)) $\land$ (c.hijoDer $\neq$ NULL $\impluego$ esMayor(c.elemento, (*c.hijoDer).elemento))}\mbox{}
  
  ~
  \AbsFc[heapmod]{}
  

  \Titulo{Representación del iterador}
  
  El iterador es simplemente un puntero al nodo siguiente.  Este puntero apunta a NULL en el caso en que la cola este vacia.

  \begin{Estructura}{itHeapMod}[itHeapmod]
    \begin{Tupla}[itHeapmod]
      \tupItem{siguiente}{puntero(nodo)}%
    \end{Tupla}
  \end{Estructura}

  \Rep[iter][it]{}

  ~

  \Abs[iter]{itBi($\alpha$)}[it]{b}{}
  
  

\end{Representacion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage

\begin{Algoritmos}

\medskip
	
 \Titulo{Algoritmos del módulo}
  	\medskip
  
\begin{algorithm}[H]{\textbf{iVacía?}(\In{c}{heapmod}) $\to$ $res$ : $bool$}
    	\begin{algorithmic}[1]
			 \State $res \gets c.tope = NULL$ \Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iPróximo}(\In{c}{heapmod}) $\to$ $res$ : $\alpha$}
    	\begin{algorithmic}[1]
			 \State $res \gets *(c.tope).elemento$ \Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iDesencolar}(\Inout{c}{heapmod})}
    	\begin{algorithmic}[1]
			\State $puntero(nodo) \ buscarUlt \gets c.tope$ \Comment {Se crea un puntero para buscar el último nodo} // $\Theta(1)$
    	 \If{$*(c.tope).hijoIzq = NULL \land *(c.tope).hijoDer = NULL$} \Comment $\Theta(1)$
    	 	\State $c.tope \gets NULL$ \Comment {Si hay un solo elemento, simplemente se elimina} // $\Theta(1)$
    	\Else
				\While{$\neg((*buscarUlt).hijoIzq = NULL \land (*buscarUlt).hijoDer = NULL)$} \Comment {} // $\Theta(1)$
					\If{$(*(*buscarUlt).hijoIzq).ramaMasLarga = *(*buscarUlt).hijoDer).ramaMasLarga$} \Comment {} // $\Theta(1)$
						\State $buscarUlt \gets (*buscarUlt).hijoDer$ \Comment {Si la profundidad es la misma, va a la derecha} // $\Theta(1)$
					\Else
						\State $buscarUlt \gets (*buscarUlt).hijoIzq$ \Comment {Si no, va a la izquierda} // $\Theta(1)$
					\EndIf
				\EndWhile
				\State $(*c.tope).elemeto \gets (*buscarUlt).elemento$ \Comment {Si elimina el tope colocando el último elemento} // $\Theta(1)$
				\State $puntero(nodo) \ padreUlt \gets (*buscarUlt).padre$ \Comment {Se crea un puntero al padre del nodo a eliminar} // $\Theta(1)$
				\If{$(*padreUlt).hijoDer = buscarUlt$} \Comment {Vemos si el nodo a eliminar es el derecho} // $\Theta(1)$
					\State $(*padreUlt).hijoDer \gets NULL$ \Comment {Eliminamos el nodo} // $\Theta(1)$
				\Else
					\State $(*padreUlt).hijoIzq \gets NULL$ \Comment {Eliminamos el nodo} // $\Theta(1)$
				\EndIf
				\State $iCorregirProfundidad(padreUlt, c)$ \Comment {Corregimos la profundidad} // $\Theta(log(\#nodos(c))$
				\State $iSiftDown(c.tope, c) $ \Comment {Se repara el heap} // $\Theta(log(\#nodos(c))$
			\EndIf

			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(\#nodos(c))$
			\Statex \underline{Justificación: }

    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iVacía}() $\to$ $res$ : $heapmod$}
    	\begin{algorithmic}[1]
			 \State $res \gets \langle NULL \rangle $ \Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$

    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iEncolar}(\In{a}{jugadorHeap}, \Inout{c}{heapmod}) $\to$ $res$ : $itHeapmod$}
    	\begin{algorithmic}[1]
			\State $puntero(nodo) \ buscarUlt \gets c.tope$ \Comment {Se crea un puntero para buscar la última posición} // $\Theta(1)$
			\If{$c.tope = NULL$} \Comment {La cola está vacia} // $\Theta(1)$
				\State $c.tope \gets \langle a,0,0,NULL,NULL,NULL \rangle$ \Comment {Se coloca el primer elemento} // $\Theta(1)$
			\Else
				\While{$(*buscarUlt).hijoIzq \neq NULL \land (*buscarUlt).hijoDer \neq NULL$} \Comment {} // $\Theta(1)$
					\If{$(*(*buscarUlt).hijoIzq).ramaMasCorta = *(*buscarUlt).hijoDer).ramaMasCorta$} \Comment {} // $\Theta(1)$
						\State $buscarUlt \gets (*buscarUlt).hijoIzq$ \Comment {Si la profundidad es la misma, va a la izquierda} // $\Theta(1)$
					\Else
						\State $buscarUlt \gets (*buscarUlt).hijoDer$ \Comment {Si no, va a la derecha} // $\Theta(1)$
					\EndIf
				\EndWhile
				\If{$(*buscarUlt).hijoIzq = NULL$} \Comment {Vemos si tiene hijo izquierdo} // $\Theta(1)$
					\State $(*buscarUlt).hijoIzq \gets \&\langle a,0,0,NULL,NULL,buscarUlt \rangle$ \Comment {Creamos el nuevo nodo} // $\Theta(1)$
					\State $buscarUlt \gets (*buscarUlt).hijoIzq$ \Comment {Nos posicionamos en el nuevo elemento} // $\Theta(1)$
				\Else
					\State $(*buscarUlt).hijoDer \gets \&\langle a,0,0,NULL,NULL,buscarUlt \rangle$ \Comment {Creamos el nuevo nodo} // $\Theta(1)$
					\State $buscarUlt \gets (*buscarUlt).hijoDer$ \Comment {Nos posicionamos en el nuevo elemento} // $\Theta(1)$
				\EndIf
				\State $iCorregirProfundidad((*buscarUlt).padre, c)$ \Comment {Corregimos la profundidad} // $\Theta(log(\#nodos(c))$
				\State $iSiftUp(buscarUlt, c) $ \Comment {Se repara el heap} // $\Theta(log(\#nodos(c))$
			\EndIf
    	\State $res \gets \&\langle buscarUlt \rangle$ \Comment {Se devuelve el iterador} // $\Theta(1)$
    	
			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(\#nodos(c))$
			\Statex \underline{Justificación:} 
    	\end{algorithmic}
\end{algorithm}
%\State {$$} \Comment {} // $\Theta(1)$
  
\begin{algorithm}[H]{\textbf{iCorregirProfundidad}(\In{p}{puntero(nodo)}, \Inout{c}{heapmod})}
    	\begin{algorithmic}[1]
    	\If{$(*p).hijoIzq \neq NULL \land (*p).hijoDer \neq NULL$} \Comment {Vemos si tiene dos hijos} // $\Theta(1)$
    		\State {$(*p).ramaMasCorta \gets 1$} \Comment {} // $\Theta(1)$
    		\State {$(*p).ramaMasLarga \gets 1$} \Comment {} // $\Theta(1)$
    	\Else
    		\State {$(*p).ramaMasCorta \gets 0$} \Comment {} // $\Theta(1)$
    		\State {$(*p).ramaMasLarga \gets 1$} \Comment {} // $\Theta(1)$
    	\EndIf
    	\State {$p \gets (*p).padre$} \Comment {Subo un nivel} // $\Theta(1)$
    	\While {$(*p).padre \neq NULL$} \Comment {Recorre hasta el tope del arbol} // $\Theta(1)$
    		\State {$(*p).ramaMasCorta \gets (*(*p).hijoDer).ramaMasCorta + 1$} \Comment {} // $\Theta(1)$
    		\State {$(*p).ramaMasLarga \gets (*(*p).hijoIzq).ramaMasLarga + 1$} \Comment {} // $\Theta(1)$
    	\EndWhile

			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(\#nodos(c))$
			\Statex \underline{Justificación:} 
    	\end{algorithmic}
\end{algorithm}
  

\begin{algorithm}[H]{\textbf{iSiftDown}(\Inout{c}{vector(puntero(nodo))}, \In{i}{nat})}
    	\begin{algorithmic}[1]
    	\State {$l \gets 2*i+1$} \Comment {Posición del hipotético hijo izquierdo} $\Theta(1)$
    	\State {$r \gets 2*i+2$} \Comment {Posición del hipotético hijo derecho} $\Theta(1)$
    	\State {$largest \gets i$}
    	\If{$l < iLongitud(c) \land c[l].dato > c[i].dato$} \Comment {Vemos si el hijo izquierdo es el mayor} $\Theta(compare(a_1, a_2))$
    		\State {$largest = l$}	\Comment {El hijo izquierdo es mayor que el padre, guardamos la posicion} $\Theta(1)$
			\EndIf
    	\If{$r < iLongitud(c) \land c[r].dato > c[largest].dato$} \Comment {Vemos si el hijo derecho es el mayor} $\Theta(compare(a_1, a_2))$
    		\State {$largest = r$}	\Comment {El hijo derecho es mayor que el padre y el hijo izquierdo, guardamos la posicion} $\Theta(1)$
			\EndIf
    	\If{$largest \neq i$} \Comment {Algun hijo es mayor} $\Theta(1)$
    		\State {$puntero(nodo) \ nuevo \gets c[i]$}  \Comment {Creamos una variable para intercambiar los elementos} $\Theta(1)$
    		\State {$c[i] \gets c[largest]$} \Comment {Intercambiamos el padre con el hijo} $\Theta(1)$
    		\State {$c[i].posicion \gets i$} \Comment {Le guardamos la nueva posición} $\Theta(1)$
    		\State {$c[largest] \gets nuevo$}	\Comment $\Theta(1)$
    		\State {$c[largest].posicion \gets largest$} \Comment {Le guardamos la nueva posición} $\Theta(1)$
    		\State {$iSiftDown(c, largest)$} \Comment {Llamamos a la funcion recursivamente} $\Theta(1)$
			\EndIf

			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(iLongitud(c)) * compare(a_1, a_2))$
			\Statex \underline{Justificación:} Todas las operaciones del algoritmo tienen costo $\Theta(1)$ excepto las comparaciones entre los datos que cuestan $\Theta(compare(a_1, a_2))$. El algoritmo recorre el vector $c$ recursivamente. En cada nueva llamada a función el índice $i$ vale el doble de lo que valía originalmente, por lo tanto pueden haber como máximo $log(iLongitud(c))$ llamadas a función, y cada una de las llamadas tiene costo $\Theta(compare(a_1, a_2))$.
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iSiftUp}(\Inout{c}{vector(puntero(nodo))}, \In{i}{nat})}
    	\begin{algorithmic}[1]
			
    	\If{$i \neq 0 \land c[(i-1)/2].dato < c[(i].dato$} \Comment {No esta al tope ni el padres es menor} $\Theta(compare(a_1, a_2))$
    		\State {$puntero(nodo) \ nuevo \gets c[i]$} \Comment {Creamos una variable para intercambiar los elementos} $\Theta(1)$
    		\State {$c[i] \gets c[(i-1)/2]$} \Comment {Intercambiamos el padre con el hijo} $\Theta(1)$
    		\State {$c[i].posicion \gets i$} \Comment {Le guardamos la nueva posición} $\Theta(1)$
    		\State {$c[(i-1)/2] \gets nuevo$} \Comment $\Theta(1)$
    		\State {$c[(i-1)/2].posicion \gets (i-1)/2$} \Comment {Le guardamos la nueva posición} $\Theta(1)$
    		\State {$iSiftUp(c, (i-1)/2)$} \Comment {Llamamos a la funcion recursivamente} $\Theta(1)$
			\EndIf
			
			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(iLongitud(c)) * compare(a_1, a_2))$
			\Statex \underline{Justificación:} Todas las operaciones del algoritmo tienen costo $\Theta(1)$ excepto las comparaciones entre los datos que cuestan $\Theta(compare(a_1, a_2))$. El algoritmo recorre el vector $c$ recursivamente. En cada nueva llamada a función el índice $i$ vale mitad de lo que valía originalmente, por lo tanto pueden haber como máximo $log(iLongitud(c))$ llamadas a función, y cada una de las llamadas tiene costo $\Theta(compare(a_1, a_2))$.
    	\end{algorithmic}
\end{algorithm}
  
\end{Algoritmos}

\end{document}
