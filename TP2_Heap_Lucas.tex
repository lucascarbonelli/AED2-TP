% % Apunte de modulos basicos
%
\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage{algorithmicx, algpseudocode, algorithm}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}


\hypersetup{%
 % Para que el PDF se abra a página completa.
 pdfstartview= {FitH \hypercalcbp{\paperheight-\topmargin-1in-\headheight}},
 pdfauthor={Cátedra de Algoritmos y Estructuras de Datos II - DC - UBA},
 pdfkeywords={Módulos básicos},
 pdftitle={Módulos básicos de diseño},
 pdfsubject={Módulos básicos de diseño}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PARAMETROS A SER MODIFICADOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%cuatrimestre de acuerdo a la opcion
\newcommand{\Cuatrimestre}{$2^\mathrm{do}$ cuatrimestre de 2016 (compilado?)}
%\newcommand{\Cuatrimestre}{$1^\mathrm{er}$ cuatrimestre de 2012 (compilado 08/05/2012)}
%\renewcommand{\Cuatrimestre}{$2^\mathrm{do}$ cuatrimestre de 2010 (compilado 13/05/2011)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OTRAS OPCIONES QUE NO HAY QUE MODIFICAR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%opening
\title{Apunte de Módulos Básicos (v.\ 0.3$\alpha$)}
\author{Algoritmos y Estructuras de Datos II, DC, UBA.}
\date{\Cuatrimestre}

% Acomodo fancyhdr.
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Algoritmos y Estructuras de Datos II}
\rhead{\Cuatrimestre}
\cfoot{\thepage /\pageref{LastPage}}
\renewcommand{\footrulewidth}{0.4pt}
\setlength{\headheight}{13pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% COMANDOS QUE ALGUN DIA PUEDAN FORMAR UN PAQUETE.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representación}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Titulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

\begin{document}

%pagina de titulo
\thispagestyle{empty}
\maketitle
\tableofcontents

\newpage


\section{Módulo Cola de prioridad($\alpha$)}

Para describir la complejidad de las operaciones, vamos a llamar $copy(a)$ al costo de copiar el elemento $a \in \alpha$ y $compare(a_1, a_2)$ al costo de comparar los elementos $a_1, a_2 \in \alpha$ (i.e., $copy$ y $compare$ son funciones de $\alpha$ en $\mathbb{N}$)\footnote{Nótese que este es un abuso de notación, ya que no estamos describiendo $copy$ y $compare$ en función del tamaño de $a$.  A la hora de usarlo, habrá que realizar la traducción}

\begin{Interfaz}

  \textbf{parámetros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{géneros}} $\alpha$\\
    \parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
    {$res \igobs a$}
    [$\Theta(copy(a))$]
    [función de copia de $\alpha$'s]
    %\TipoFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$} \qquad función de copia, con costo temporal $\Theta(copy(a))$.
  }\\[2ex]
	\parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
	\InterfazFuncion{\argumento $<$ \argumento}{\In{a_1}{$\alpha$}, \In{a_2}{$\alpha$}}{bool} 
    {$res \igobs a_1 < a_2$}
    [$\Theta(compare(a_1, a_2))$]
    [función de comparación de $\alpha$'s]
    %\TipoFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$} \qquad función de copia, con costo temporal $\Theta(copy(a))$.
  }
  

  \textbf{se explica con}: \tadNombre{Cola de prioridad$(\alpha)$}.

  \textbf{géneros}: \TipoVariable{colaPrior$(\alpha)$}.
  
  \Titulo{Operaciones básicas de cola de prioridad($\alpha$)}
  
  \InterfazFuncion{Vacía?}{\In{c}{colaPrior$(\alpha)$}}{bool}
  {res $\igobs$ vacía?($\alpha$)}
  [$\Theta(1)$]
  [Devuelve true si la cola de prioridad está vacia.]

  \InterfazFuncion{Próximo}{\In{c}{colaPrior$(\alpha)$}}{$\alpha$}
  [$\lnot$vacía?(c)]
  {alias($res$, próximo())}
  [$\Theta(1)$]
  [Retorna por referencia el próximo valor en la cola.]
  [La referencia es constante, el elemento a no puede modificarse]
  
  \InterfazFuncion{Desncolar}{\Inout{c}{colaPrior$(\alpha)$}}{}
  [$\lnot$vacía?(c) $\land$ $c \igobs c_0$]
  {c $\igobs$ desencolar($c_0$)}
  [$\Theta\left(log\left(\displaystyle\sum_{a' \in c}compare(a,a')\right)\right)$]
  [Desencola el próximo elemento.]
  
  \InterfazFuncion{Vacía}{}{colaPrior$(\alpha)$}
  {$res$ $\igobs$ vacía()}
  [$\Theta(1)$]
  [Retorna por referencia una cola vacía.]

  \InterfazFuncion{Encolar}{\In{a}{$\alpha$}, \Inout{c}{colaPrior$(\alpha)$}}{itColarPrior$(\alpha)$}
  [$c \igobs c_0$]
  {c $\igobs$ encolar($c_0$) $\land$ HaySiguiente($res$) $\land_L$ Siguiente($res$) $=$ $a$ $\land$ alias(esPermutacion?(SecuSuby($res$), $c$))}
  [$\Theta\left(log\left(\displaystyle\sum_{a' \in c}compare(a,a')\right)\right)$]
  [Encola el elemento a. El elemento $a$ se agrega por copia.  El iterador se invalida si y sólo si se elimina el elemento siguiente del iterador sin utilizar la función \NombreFuncion{EliminarSiguiente}.  Además, anteriores($res$) y siguientes($res$) podrían cambiar completamente ante cualquier operación que modifique $c$ sin utilizar las funciones del iterador.]
  
  
  
  
  \Titulo{Operaciones del iterador}

  El iterador que presentamos permite modificar la cola de prioridad recorrida, eliminando elementos. Sin embargo, cuando el conjunto es no modificable, no se pueden utilizar las funciones de eliminación. Además, los elementos iterados no pueden modificarse, por cuestiones de implementación.

  \InterfazFuncion{CrearIt}{\In{c}{colarPrior($\alpha$)}}{itColarPrior($\alpha$)}
  {alias(esPermutacion?(SecuSuby($res$), $c$)) $\land$ vacia?(Anteriores($res$))}
  [$\Theta(1)$]
  [crea un iterador bidireccional del conjunto, de forma tal que \NombreFuncion{HayAnterior} evalúe a \texttt{false} (i.e., que se pueda recorrer los elementos aplicando iterativamente \NombreFuncion{Siguiente}).]
  [El iterador se invalida si y sólo si se elimina el elemento siguiente del iterador sin utilizar la función \NombreFuncion{EliminarSiguiente}.  Además, anteriores($res$) y siguientes($res$) podrían cambiar completamente ante cualquier operación que modifique $c$ sin utilizar las funciones del iterador.]

  \InterfazFuncion{HaySiguiente}{\In{it}{itColarPrior($\alpha$)}}{bool}
  {$res$ $\igobs$ haySiguiente?($it$)}
  [$\Theta(1)$]
  [devuelve \texttt{true} si y sólo si en el iterador todavía quedan elementos para avanzar.]

  \InterfazFuncion{HayAnterior}{\In{it}{itColarPrior($\alpha$)}}{bool}
  {$res$ $\igobs$ hayAnterior?($it$)}
  [$\Theta(1)$]
  [devuelve \texttt{true} si y sólo si en el iterador todavía quedan elementos para retroceder.]

  \InterfazFuncion{Siguiente}{\In{it}{itColarPrior($\alpha$)}}{$\alpha$}
  [HaySiguiente?($it$)]
  {alias($res$ $\igobs$ Siguiente($it$))}
  [$\Theta(1)$]
  [devuelve el elemento siguiente a la posición del iterador.]
  [$res$ no es modificable.]


  \InterfazFuncion{Anterior}{\In{it}{itColarPrior($\alpha$)}}{$\alpha$}
  [HayAnterior?($it$)]
  {alias($res$ $\igobs$ Anterior($it$))}
  [$\Theta(1)$]
  [devuelve el elemento anterior a la posición del iterador.]
  [$res$ no es modificable.]

  \InterfazFuncion{Avanzar}{\Inout{it}{itColarPrior($\alpha$)}}{}
  [$it = it_0$ $\land$ HaySiguiente?($it$)]
  {$it$ $\igobs$ Avanzar($it_0$)}
  [$\Theta(1)$]
  [Avanza a la posición siguiente del iterador.]

  \InterfazFuncion{Retroceder}{\Inout{it}{itColarPrior($\alpha$)}}{}
  [$it = it_0$ $\land$ HayAnterior?($it$)]
  {$it$ $\igobs$ Retroceder($it_0$)}
  [$\Theta(1)$]
  [Retrocede a la posición anterior del iterador.]

  \InterfazFuncion{EliminarSiguiente}{\Inout{it}{itColarPrior($\alpha$)}}{}
  [$it = it_0$ $\land$ HaySiguiente?($it$)]
  {$it$ $\igobs$ EliminarSiguiente($it_0$)}
  [$\Theta\left(log\left(\displaystyle\sum_{a' \in SecuSuby(it)}compare(Siguiente(it),a')\right)\right)$]
  [Elimina de la lista iterada el valor que se encuentra en la posición siguiente del iterador.]

  \InterfazFuncion{EliminarAnterior}{\Inout{it}{itColarPrior($\alpha$)}}{}
  [$it = it_0$ $\land$ HayAnterior?($it$)]
  {$it$ $\igobs$ EliminarAnterior($it_0$)}
  [$\Theta\left(log\left(\displaystyle\sum_{a' \in SecuSuby(it)}compare(Anterior(it),a')\right)\right)$]
  [Elimina de la lista iterada el valor que se encuentra en la posición anterior del iterador.]
  
    
\end{Interfaz}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Representacion}

  \Titulo{Representación de la Cola de Prioridad}
  
  En este módulo vamos a utilizar un vector para representar la cola
  
  \begin{Estructura}{colaPrior$(\alpha)$}[vector($\alpha$)]
  \end{Estructura}

  \RepFc[vector({$\alpha$})][c]{($\forall i$: nat) ($0 < i <$ Longitud(c)) $c[(i-1)/2] < c[i]$}

  ~

  \AbsFc[vector({$\alpha$})]{colaPrior($\alpha$)}[c]{\IF vacia?($c$) THEN vacía ELSE encolar(Ultimo($c$), Abs(Comienzo($c$))) FI}.
  
  
  \Titulo{Representación del iterador}
  
  El iterador de la cola de prioridad 
  
  \begin{Estructura}{itColaPrior$(\alpha)$}[itector($\alpha$)]
  \end{Estructura}

  \RepFc[itVector({$\alpha$})][it]{true}

  ~

  \AbsFc[itVector({$\alpha$})]{itBi($\alpha$)}[it]{b}{Anteriores($b$) $=$ Anteriores($it$) $\land$ Siguientes($b$) $=$ Siguientes($it$)}\mbox{}
  
\end{Representacion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Algoritmos}

\medskip
	
 \Titulo{Algoritmos del módulo}
  	\medskip
  
\begin{algorithm}[H]{\textbf{iVacía?}() $\to$ $res$ : vector($\alpha$)}
    	\begin{algorithmic}[1]
			 \State $res \gets \langle NULL, 0 \rangle$ \Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iPróximo}(\In{c}{vector$(\alpha)$}) $\to$ $res$ : $\alpha$}
    	\begin{algorithmic}[1]
			 \State $res \gets \langle NULL, 0 \rangle$ \Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iPróximo}(\In{c}{vector$(\alpha)$}) $\to$ $res$ : $\alpha$}
    	\begin{algorithmic}[1]
			 \State $res \gets \langle NULL, 0 \rangle$ \Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iPróximo}(\In{c}{vector$(\alpha)$}) $\to$ $res$ : $\alpha$}
    	\begin{algorithmic}[1]
			 \State $res \gets \langle NULL, 0 \rangle$ \Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iPróximo}(\In{c}{vector$(\alpha)$}) $\to$ $res$ : $\alpha$}
    	\begin{algorithmic}[1]
			 \State $res \gets \langle NULL, 0 \rangle$ \Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}
  
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Titulo{Algoritmos del iterador}	
 
\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\State \textbf{iCrearIt}(\In{l}{lst}) $\to$ $res$ : iter
		
			\State $res \gets \langle l.primero, l \rangle$ 	\Comment $\Theta(1)$
    	
		\medskip
		\Statex \underline{Complejidad:} $\Theta(1)$
    \end{algorithmic}
\end{algorithm}	


\end{Algoritmos}

\end{document}
