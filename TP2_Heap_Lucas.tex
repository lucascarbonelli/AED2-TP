% % Apunte de modulos basicos
%
\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}
\usepackage{algorithmicx, algpseudocode, algorithm}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}


\hypersetup{%
 % Para que el PDF se abra a página completa.
 pdfstartview= {FitH \hypercalcbp{\paperheight-\topmargin-1in-\headheight}},
 pdfauthor={Cátedra de Algoritmos y Estructuras de Datos II - DC - UBA},
 pdfkeywords={Módulos básicos},
 pdftitle={Módulos básicos de diseño},
 pdfsubject={Módulos básicos de diseño}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PARAMETROS A SER MODIFICADOS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%cuatrimestre de acuerdo a la opcion
\newcommand{\Cuatrimestre}{$2^\mathrm{do}$ cuatrimestre de 2016 (compilado?)}
%\newcommand{\Cuatrimestre}{$1^\mathrm{er}$ cuatrimestre de 2012 (compilado 08/05/2012)}
%\renewcommand{\Cuatrimestre}{$2^\mathrm{do}$ cuatrimestre de 2010 (compilado 13/05/2011)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OTRAS OPCIONES QUE NO HAY QUE MODIFICAR
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%opening
\title{Apunte de Módulos Básicos (v.\ 0.3$\alpha$)}
\author{Algoritmos y Estructuras de Datos II, DC, UBA.}
\date{\Cuatrimestre}

% Acomodo fancyhdr.
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Algoritmos y Estructuras de Datos II}
\rhead{\Cuatrimestre}
\cfoot{\thepage /\pageref{LastPage}}
\renewcommand{\footrulewidth}{0.4pt}
\setlength{\headheight}{13pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% COMANDOS QUE ALGUN DIA PUEDAN FORMAR UN PAQUETE.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representación}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Titulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

\begin{document}

%pagina de titulo
\thispagestyle{empty}
\maketitle
\tableofcontents

\newpage

\section{Renombres de TADs}

\tadNombre{TAD NodoHeap($\alpha$)} es \tadNombre{Tupla(Nat,$\alpha$)}

\section{Módulo Heap Modificable($\alpha$)}

Este módulo implementa una cola de prioridad que permite eliminar elemntos en tiempo logaritmico. La cola de prioridad está formada por un conjunto de nodos, los cuales contienen el elemento que se quiere colocar en la cola y un número que define univocamente la prioridad del elemento respecto del resto de los elemento en la cola.

Para describir la complejidad de las operaciones, vamos a llamar $copy(a)$ al costo de copiar el elemento $a \in \alpha$ y $compare(a_1, a_2)$ al costo de comparar los elementos $a_1, a_2 \in \alpha$ (i.e., $copy$ y $compare$ son funciones de $\alpha$ en $\mathbb{N}$)\footnote{Nótese que este es un abuso de notación, ya que no estamos describiendo $copy$ y $compare$ en función del tamaño de $a$.  A la hora de usarlo, habrá que realizar la traducción}

\begin{Interfaz}

  \textbf{parámetros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{géneros}} $\alpha$\\
    \parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
    {$res \igobs a$}
    [$\Theta(copy(a))$]
    [función de copia de $\alpha$'s]
    %\TipoFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$} \qquad función de copia, con costo temporal $\Theta(copy(a))$.
  }\\[2ex]
	\parbox[t]{1.7cm}{\textbf{función}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
	\InterfazFuncion{\argumento $<$ \argumento}{\In{a_1}{$\alpha$}, \In{a_2}{$\alpha$}}{bool} 
    {$res \igobs a_1 < a_2$}
    [$\Theta(compare(a_1, a_2))$]
    [función de comparación de $\alpha$'s]
    %\TipoFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$} \qquad función de copia, con costo temporal $\Theta(copy(a))$.
  }
  

  \textbf{se explica con}: \tadNombre{Cola de prioridad$(\alpha)$}, \tadNombre{NodoHeap$(\alpha)$}.

  \textbf{géneros}: \TipoVariable{heapMod$(\alpha)$}.
  
  \Titulo{Operaciones básicas de Heap Modificable($\alpha$)}
  
  \InterfazFuncion{Vacía?}{\In{c}{heapMod$(\alpha)$}}{bool}
  {res $\igobs$ vacía?($\alpha$)}
  [$\Theta(1)$]
  [Devuelve true si la cola de prioridad está vacia.]

  \InterfazFuncion{Próximo}{\In{c}{heapMod$(\alpha)$}}{$\alpha$}
  [$\lnot$vacía?(c)]
  {alias($res$, próximo())}
  [$\Theta(1)$]
  [Retorna por referencia el próximo valor en la cola.]
  [La referencia es constante, el elemento a no puede modificarse]
  
  \InterfazFuncion{Desncolar}{\Inout{c}{heapMod$(\alpha)$}}{}
  [$\lnot$vacía?(c) $\land$ $c \igobs c_0$]
  {c $\igobs$ desencolar($c_0$)}
  [$\Theta\left(log\left(\displaystyle\sum_{a' \in heapSecu(c)}compare(a,a')\right)\right)$]
  [Desencola el próximo elemento.]
  
\newpage  
  
  \InterfazFuncion{Vacía}{}{heapMod$(\alpha)$}
  {$res$ $\igobs$ vacía()}
  [$\Theta(1)$]
  [Retorna por referencia una cola vacía.]

  \InterfazFuncion{Encolar}{\In{a}{$\alpha$}, \Inout{c}{heapMod$(\alpha)$}}{NodoHeap$(\alpha)$}
  [$c \igobs c_0$]
  {c $\igobs$ encolar($c_0$) $\land$ $\Pi_{2}(res) \igobs a$}
%  {c $\igobs$ encolar($c_0$) $\land$ $\Pi_{2}$(res) $\igobs$ a $\land$ $\Pi_{1}$(res) $<$ $\#$ heapSecu(c) $\land$ \\($\Pi_{1}$(res) $=$ 0 $\lor$ (($\exists$ x $\in$ heapSecu(c)) $\Pi_{1}$(x) = ($\Pi_{1}(res)-1)/2$ $\land$ $\Pi_{2}$(res) $<$ $\Pi_{2}$(x))) $\land$ \\($\Pi_{1}$(res) $>$ $\#$heapSecu(c)/2 $\lor$ (($\exists$ x,y $\in$ heapSecu(c)) \\$\Pi_{1}$(x) = (2*$\Pi_{1}(res)$)+1 $\land$ $\Pi_{2}$(x) $<$ $\Pi_{2}$(res) $\land$ \\$\Pi_{1}$(y) = (2*$\Pi_{1}(res)$)+2 $\land$ $\Pi_{2}$(y) $<$ $\Pi_{2}$(res)))}
  [$\Theta\left(log\left(\displaystyle\sum_{a' \in heapSecu(c)}compare(a,a')\right)\right)$]
  [Encola el elemento $a$. Devuelve un nodo que coniene una referencia al elemento agregado $a$.]
  
  
  \InterfazFuncion{Eliminar}{\Inout{c}{heapMod$(\alpha)$}, \In{a}{NodoHeap($\alpha$)}}{}
  [$c \igobs c_0 \land a \in heapSecu(c_0)$]
  {$c \igobs eliminar(c_0, \Pi_{2}(a))$}
  [$\Theta\left(log\left(\displaystyle\sum_{a' \in heapSecu(c)}compare(a,a')\right)\right)$]
  [Elimina el elemento $a$.]
  
  
  \Titulo{Especificación de las operaciones auxiliares utilizadas en la interfaz}
  
  \begin{tad}{Cola de Prioridad extendida}
    \parskip=0pt
    \tadExtiende{\tadNombre{Cola de Prioridad}}
    
    \tadTitulo{otras operaciones}
    
    \tadAlinearFunciones{eliminar(c, a)}{heapMod($\alpha$), $\alpha$/a}
    \tadOperacion{eliminar}{heapMod($\alpha$), $\alpha$/a}{heapMod($\alpha$)}{$a \in heapSecu(c_0)$}
    \tadOperacion{heapSecu}{heapMod($\alpha$)}{secu($\alpha$)}{}
    
    \tadAxiomas
    \tadAlinearAxiomas{eliminar(c, a)}
    \tadAxioma{eliminar(c, $a$)}{\IF vacía?(c) THEN c ELSE {\IF próximo(c) = $a$ THEN desencolar(c) ELSE encolar(próximo(c), eliminar(desencolar(c), $a$))) FI} FI}
    \tadAxioma{heapSecu(c)}{\IF vacía?(c) THEN $<>$ ELSE próximo(c) $\bullet$ heapSecu(desencolar(c)) FI}
  \end{tad}
  
   
\end{Interfaz}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Representacion}

  \Titulo{Representación de la Cola de Prioridad}
  
  En este módulo vamos a utilizar un vector para representar la cola, donde cada elemento es un puntero a una tupla (nodo). La primera componente del nodo es la posicion de la tupla en el vector, mientras que la segunda componente es el elemento que queremos colocar en la cola de prioridad. Siendo n la posición de un elemento dado, debe cumplirse que los elementos en las posiciones 2*n+1 y 2*n+2 tienen menor prioridad que el elemento en la posición n, y el elemento en la posición (n-1)/2 tiene mayor prioridad.
  
  \begin{Estructura}{heapMod$(\alpha)$}[vector(puntero(nodo))]
    \begin{Tupla}[nodo]
      \tupItem{posicion}{nat}%
      \tupItem{dato}{$\alpha$}%
    \end{Tupla}
  \end{Estructura}

	%\RepFc[vector(puntero(nodo))][c]{true}
  \Rep[vector( puntero(nodo))][c]{($\forall i$: nat) ($0 \leq i <$ Longitud(c)) $\impluego$ $c[i].posicion = i$ $\land$\\(($\forall i$: nat) ($0 < i <$ Longitud(c)) $\impluego$ $c[i].dato < c[(i-1)/2].dato$) $\land$\\ (($\forall i$: nat) ($0 \leq i <$ (Longitud(c)-1)/2) $\impluego$ $c[(2*i)+1].dato < c[i].dato \land c[(2*i)+2].dato < c[i].dato$))\\$\land$ (esPar(Longitud(c)) $\impluego$ c[Longitud(c)-1].dato < c[(Longitud(c)-1)/2].dato)}\mbox{}
  
  ~

  \tadOperacion{esPar}{nat}{bool}{}
  \tadAxioma{esPar($n$)}{\IF $n \leq 1$ THEN $n = 0?$ ELSE esPar($n-2$) FI}
  ~
  \AbsFc[vector({nodo})]{colaPrior($\alpha$)}[c]{\IF vacia?($c$) THEN vacía ELSE encolar(Ultimo($c$).dato, Abs(Comienzo($c$))) FI}
  

\end{Representacion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage

\begin{Algoritmos}

\medskip
	
 \Titulo{Algoritmos del módulo}
  	\medskip
  
\begin{algorithm}[H]{\textbf{iVacía?}(\In{c}{vector(puntero(nodo))}) $\to$ $res$ : $bool$}
    	\begin{algorithmic}[1]
			 \State $res \gets iLongitud(c) = 0$ \Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iPróximo}(\In{c}{vector(puntero(nodo))}) $\to$ $res$ : $\alpha$}
    	\begin{algorithmic}[1]
			 \State $res \gets c[0].dato$ \Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iDesncolar}(\Inout{c}{vector(puntero(nodo))})}
    	\begin{algorithmic}[1]
    	 \If{$iLongitud(c) = 1$} \Comment $\Theta(1)$
    	 	\State $iEliminar(c, 0) $ \Comment {Si hay un solo elemento, simplemente se elimina} // $\Theta(1)$
    	\Else
				\State $c[0] \gets c[iLongitud(c)-1]$ \Comment{Sino, intercambiamos con el ultimo	// $\Theta(1)$}
				\State $c[0].posicion \gets 0$ \Comment{Se coloca la posicion correcta // $\Theta(1)$}
				\State $iElimnar(c, iLongitud(c)-1)$ \Comment{Se elimina el elemento en la ultima posicion	// $\Theta(1)$}
			\EndIf
			 \State $iSiftDown(c, 0)$ \Comment {Se repara el heap} // $\Theta(log(iLongitud(c)))$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(iLongitud(c)))$
			\Statex \underline{Justificación: $\Theta(1) + \Theta(1) + \Theta(1) + \Theta(1) + \Theta(1) + \Theta(log(iLongitud(c))) = \Theta(log(iLongitud(c)))$} 

    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iVacía}() $\to$ $res$ : $vector( puntero(nodo))$}
    	\begin{algorithmic}[1]
			 \State $res \gets iVacia()$ \Comment $\Theta(1)$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$

    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iEncolar}(\In{a}{$\alpha$}, \Inout{c}{vector(puntero(nodo))}) $\to$ $res$ : $nodo$}
    	\begin{algorithmic}[1]
    	\State $puntero(nodo) \ nuevo \gets \& \langle iLongitud(c), a \rangle$ \Comment {Se crea un nuevo nodo, $a$ se pasa por referencia} // $\Theta(1)$
  		\State $iAgregarAtras(c, nuevo)$ \Comment {Se agrega al final del vector el nuevo elemento} // $\Theta(($f$(long($c$)) $+$ $copy(nuevo)$))$
  		\State $iSiftUp(c, iLongitud(c)-1) $ \Comment {Se repara el heap} // $\Theta(log(iLongitud(c)))$
    	
			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(iLongitud(c)) + ($f$(long($c$)) $+$ $copy(nuevo)$)) = \Theta(log(iLongitud(c)) + copy(nuevo))) amortizado$
			\Statex \underline{Justificación:} el algoritmo llama a la función $iAgregarAtras$ que agrega un elemento al final de un vector, tiene complejidad $\Theta(($f$(long($c$)) $+$ $copy(nuevo)$))$ = $\Theta(copy(nuevo)) \ amortizado$, luego la suma de las complejidades es $\Theta(1) + \Theta(copy(nuevo)) amortizado) + \Theta(log(iLongitud(c))) = \Theta(log(iLongitud(c)) + copy(nuevo))$
    	\end{algorithmic}
\end{algorithm}
  
  
\begin{algorithm}[H]{\textbf{iEliminar}(\Inout{c}{vector(puntero(nodo))}, \In{a}{nodo})}
    	\begin{algorithmic}[1]
    	 \If{$iLongitud(c) = 1$} \Comment $\Theta(1)$
    	 	\State $iEliminar(c, 0) $ \Comment {Si hay un solo elemento, simplemente se elimina} // $\Theta(1)$
    	\Else
				\State $c[a.posicion] \gets c[iLongitud(c)-1]$ \Comment{Sino, intercambiamos con el ultimo	// $\Theta(1)$}
				\State $c[a.posicion].posicion \gets a.posicion$ \Comment{Se coloca la posicion correcta // $\Theta(1)$}
				\State $iElimnar(c, iLongitud(c)-1)$ \Comment{Se elimina el elemento en la ultima posicion	// $\Theta(1)$}
			\EndIf
			 \State $iSiftUp(c, iLongitud(c)-1)$ \Comment {Se repara el heap} // $\Theta(log(iLongitud(c)))$

			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(iLongitud(c)))$
			\Statex \underline{Justificación:} $\Theta(1) + \Theta(1) + \Theta(1) + \Theta(1) + \Theta(1) + \Theta(log(iLongitud(c))) = \Theta(log(iLongitud(c)))$
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iSiftDown}(\Inout{c}{vector(puntero(nodo))}, \In{i}{nat})}
    	\begin{algorithmic}[1]
    	\State {$l \gets 2*i+1$} \Comment {Posición del hipotético hijo izquierdo} $\Theta(1)$
    	\State {$r \gets 2*i+2$} \Comment {Posición del hipotético hijo derecho} $\Theta(1)$
    	\State {$largest \gets i$}
    	\If{$l < iLongitud(c) \land c[l].dato > c[i].dato$} \Comment {Vemos si el hijo izquierdo es el mayor} $\Theta(compare(a_1, a_2))$
    		\State {$largest = l$}	\Comment {El hijo izquierdo es mayor que el padre, guardamos la posicion} $\Theta(1)$
			\EndIf
    	\If{$r < iLongitud(c) \land c[r].dato > c[largest].dato$} \Comment {Vemos si el hijo derecho es el mayor} $\Theta(compare(a_1, a_2))$
    		\State {$largest = r$}	\Comment {El hijo derecho es mayor que el padre y el hijo izquierdo, guardamos la posicion} $\Theta(1)$
			\EndIf
    	\If{$largest \neq i$} \Comment {Algun hijo es mayor} $\Theta(1)$
    		\State {$puntero(nodo) \ nuevo \gets c[i]$}  \Comment {Creamos una variable para intercambiar los elementos} $\Theta(1)$
    		\State {$c[i] \gets c[largest]$} \Comment {Intercambiamos el padre con el hijo} $\Theta(1)$
    		\State {$c[i].posicion \gets i$} \Comment {Le guardamos la nueva posición} $\Theta(1)$
    		\State {$c[largest] \gets nuevo$}	\Comment $\Theta(1)$
    		\State {$c[largest].posicion \gets largest$} \Comment {Le guardamos la nueva posición} $\Theta(1)$
    		\State {$iSiftDown(c, largest)$} \Comment {Llamamos a la funcion recursivamente} $\Theta(1)$
			\EndIf

			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(iLongitud(c)) * compare(a_1, a_2))$
			\Statex \underline{Justificación:} Todas las operaciones del algoritmo tienen costo $\Theta(1)$ excepto las comparaciones entre los datos que cuestan $\Theta(compare(a_1, a_2))$. El algoritmo recorre el vector $c$ recursivamente. En cada nueva llamada a función el índice $i$ vale el doble de lo que valía originalmente, por lo tanto pueden haber como máximo $log(iLongitud(c))$ llamadas a función, y cada una de las llamadas tiene costo $\Theta(compare(a_1, a_2))$.
    	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]{\textbf{iSiftUp}(\Inout{c}{vector(puntero(nodo))}, \In{i}{nat})}
    	\begin{algorithmic}[1]
			
    	\If{$i \neq 0 \land c[(i-1)/2].dato < c[(i].dato$} \Comment {No esta al tope ni el padres es menor} $\Theta(compare(a_1, a_2))$
    		\State {$puntero(nodo) \ nuevo \gets c[i]$} \Comment {Creamos una variable para intercambiar los elementos} $\Theta(1)$
    		\State {$c[i] \gets c[(i-1)/2]$} \Comment {Intercambiamos el padre con el hijo} $\Theta(1)$
    		\State {$c[i].posicion \gets i$} \Comment {Le guardamos la nueva posición} $\Theta(1)$
    		\State {$c[(i-1)/2] \gets nuevo$} \Comment $\Theta(1)$
    		\State {$c[(i-1)/2].posicion \gets (i-1)/2$} \Comment {Le guardamos la nueva posición} $\Theta(1)$
    		\State {$iSiftUp(c, (i-1)/2)$} \Comment {Llamamos a la funcion recursivamente} $\Theta(1)$
			\EndIf
			
			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(iLongitud(c)) * compare(a_1, a_2))$
			\Statex \underline{Justificación:} Todas las operaciones del algoritmo tienen costo $\Theta(1)$ excepto las comparaciones entre los datos que cuestan $\Theta(compare(a_1, a_2))$. El algoritmo recorre el vector $c$ recursivamente. En cada nueva llamada a función el índice $i$ vale mitad de lo que valía originalmente, por lo tanto pueden haber como máximo $log(iLongitud(c))$ llamadas a función, y cada una de las llamadas tiene costo $\Theta(compare(a_1, a_2))$.
    	\end{algorithmic}
\end{algorithm}
  
\end{Algoritmos}

\end{document}
